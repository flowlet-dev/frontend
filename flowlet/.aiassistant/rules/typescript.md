---
apply: ファイルパターンによる
---

# TypeScript ルール

## ドキュメント概要

このドキュメントは、TypeScriptに関する「AIアシスタントの判断基準」を定めます。  
目的は **型安全性・保守性・読みやすさ** を高い優先度で維持しながら、変更の影響範囲を小さくすることです。

---

## 最優先の原則（迷ったらここ）

1. **型で守れるものは型で守る**（実行時チェックは「境界」で行う）
2. **any は原則禁止**（やむを得ない場合は理由と代替案を提示）
3. **推論を活かしつつ、API境界は明示する**（入出力・公開関数）
4. **壊れにくい変更**（型の一貫性、後方互換、変更点の局所化）
5. **読み手の認知負荷を下げる**（命名、責務分離、過剰なジェネリクス回避）

---

## 型設計ルール

### 1) 公開API・境界の型は明示

- export する関数/クラス/コンポーネントの **引数・戻り値** は明示する
- 外部入力（APIレスポンス、localStorage、URLクエリ、env等）は **unknown で受ける** → 解析して型を確定

### 2) any禁止（例外運用あり）

- 基本方針: `any` を導入しない
- 代替の優先順位:
    1. `unknown` + 型ガード
    2. ジェネリクス
    3. 適切なユニオン型 / リテラル型
- どうしても必要な場合:
    - `// NOTE: any理由（外部ライブラリ都合等）。将来の置換案: ...` を添える
    - 影響範囲を最小化（局所変数に閉じる）

### 3) null/undefined の扱いを統一

- 値が存在しない: **原則 `undefined`**
- `null` は外部仕様（APIがnullを返す等）で必要なときのみ
- オプショナルは「存在しない可能性」を意味する。安易に `?` を増やさない

### 4) ユニオン型は「判別可能」にする

- 可能なら discriminated union（例: `{ kind: 'a' } | { kind: 'b' }`）
- `switch` で分岐する場合は **exhaustive check** を入れる

### 5) interface / type の使い分け

- 基本は `type` を使う（合成・ユニオンに強い）
- `interface` は「拡張される前提の公開契約」や宣言マージが欲しい場合のみ

---

## 実装ルール（書き方）

### 1) 推奨する型の書き方

- 配列: `T[]`（可読性が落ちる場合のみ `Array<T>`）
- 関数型: `() => R`、引数が多いときは型エイリアス化
- オブジェクト: 必要以上に型注釈しない（推論を活かす）

### 2) 型アサーション（as）を乱用しない

- `as` は「正当化できる」場合のみ（型ガードで代替できるならそちら）
- `as const` はリテラル型を保持したい場面で積極的に使う

### 3) enum は原則使わない

- 原則: 文字列リテラルユニオン + `as const` のオブジェクトを使う
- 例外: 既存資産との互換や、どうしても必要な場合のみ

### 4) 非同期処理

- Promiseチェーンより `async/await` を優先
- `try/catch` は「回復できる」境界に寄せる（内部で握り潰さない）
- 返り値の型は `Promise<T>` を明示（公開APIは特に）

---

## 型ガード・バリデーション（境界で実施）

### 1) 外部入力は unknown → 解析

- JSON.parse の結果は `unknown` として扱う
- 最低限:
    - 必須フィールドの存在
    - 型（string/number/object等）
    - 配列要素の型

### 2) 型ガードの指針

- 小さく、再利用可能に
- `in` / `typeof` / `Array.isArray` を基本に、過度に複雑にしない

---

## コード整理・命名

- 型名: `PascalCase`（例: `UserId`, `ApiResponse`）
- 変数/関数: `camelCase`（例: `fetchUser`）
- boolean は `is/has/can/should` で始める（例: `isLoading`）
- 「型で表現できる曖昧さ」は命名で補強（例: `rawUser` / `validatedUser`）

---

## 変更時のAIの振る舞い（提案の出し方）

- 変更提案は次をセットで提示する:
    1. **何を変えるか**
    2. **なぜ安全か/なぜ必要か**
    3. **影響範囲**
    4. **代替案（あれば）**
- 破壊的変更が疑われる場合は、互換案（旧型サポートや移行手順）を併記する

---

## 例（短い推奨パターン）

```typescript
type User = { id: string; name: string; };
const isUser = (v: unknown): v is User => {
    if (typeof v !== "object" || v === null) return false;
    const o = v as Record<string, unknown>;
    return typeof o.id === "string" && typeof o.name === "string";
};
export const parseUser = (v: unknown): User => {
    if (!isUser(v)) throw new Error("Invalid user");
    return v;
};
```

## 禁止/非推奨まとめ

- `any` の安易な導入
- 根拠のない `as SomeType`
- 境界以外での過剰な実行時バリデーション
- 可読性を落とす過剰なジェネリクス
- `enum` の無目的な使用